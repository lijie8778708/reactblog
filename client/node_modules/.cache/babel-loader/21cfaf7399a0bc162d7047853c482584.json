{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tagtypes_1 = require(\"./tagtypes\");\n/**\n * Search a node and its children for nodes passing a test function.\n *\n * @param test Function to test nodes on.\n * @param element Element to search. Will be included in the result set if it matches.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n */\n\n\nfunction filter(test, node, recurse, limit) {\n  if (recurse === void 0) {\n    recurse = true;\n  }\n\n  if (limit === void 0) {\n    limit = Infinity;\n  }\n\n  if (!Array.isArray(node)) node = [node];\n  return find(test, node, recurse, limit);\n}\n\nexports.filter = filter;\n/**\n * Like `filter`, but only works on an array of nodes.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n */\n\nfunction find(test, nodes, recurse, limit) {\n  var result = [];\n\n  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n    var elem = nodes_1[_i];\n\n    if (test(elem)) {\n      result.push(elem);\n      if (--limit <= 0) break;\n    }\n\n    if (recurse && tagtypes_1.hasChildren(elem) && elem.children.length > 0) {\n      var children = find(test, elem.children, recurse, limit);\n      result.push.apply(result, children);\n      limit -= children.length;\n      if (limit <= 0) break;\n    }\n  }\n\n  return result;\n}\n\nexports.find = find;\n/**\n * Finds the first element inside of an array that matches a test function.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n */\n\nfunction findOneChild(test, nodes) {\n  return nodes.find(test);\n}\n\nexports.findOneChild = findOneChild;\n/**\n * Finds one element in a tree that passes a test.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n */\n\nfunction findOne(test, nodes, recurse) {\n  if (recurse === void 0) {\n    recurse = true;\n  }\n\n  var elem = null;\n\n  for (var i = 0; i < nodes.length && !elem; i++) {\n    var checked = nodes[i];\n\n    if (!tagtypes_1.isTag(checked)) {\n      continue;\n    } else if (test(checked)) {\n      elem = checked;\n    } else if (recurse && checked.children.length > 0) {\n      elem = findOne(test, checked.children);\n    }\n  }\n\n  return elem;\n}\n\nexports.findOne = findOne;\n/**\n * Returns whether a tree of nodes contains at least one node passing a test.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n */\n\nfunction existsOne(test, nodes) {\n  return nodes.some(function (checked) {\n    return tagtypes_1.isTag(checked) && (test(checked) || checked.children.length > 0 && existsOne(test, checked.children));\n  });\n}\n\nexports.existsOne = existsOne;\n/**\n * Search and array of nodes and its children for nodes passing a test function.\n *\n * Same as `find`, only with less options, leading to reduced complexity.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n */\n\nfunction findAll(test, nodes) {\n  var _a;\n\n  var result = [];\n  var stack = nodes.filter(tagtypes_1.isTag);\n  var elem;\n\n  while (elem = stack.shift()) {\n    var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(tagtypes_1.isTag);\n\n    if (children && children.length > 0) {\n      stack.unshift.apply(stack, children);\n    }\n\n    if (test(elem)) result.push(elem);\n  }\n\n  return result;\n}\n\nexports.findAll = findAll;","map":{"version":3,"sources":["/Users/jieli/Desktop/reactblog/client/node_modules/html-to-react/node_modules/domutils/lib/querying.js"],"names":["Object","defineProperty","exports","value","tagtypes_1","require","filter","test","node","recurse","limit","Infinity","Array","isArray","find","nodes","result","_i","nodes_1","length","elem","push","hasChildren","children","apply","findOneChild","findOne","i","checked","isTag","existsOne","some","findAll","_a","stack","shift","unshift"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tagtypes_1 = require(\"./tagtypes\");\n/**\n * Search a node and its children for nodes passing a test function.\n *\n * @param test Function to test nodes on.\n * @param element Element to search. Will be included in the result set if it matches.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n */\nfunction filter(test, node, recurse, limit) {\n    if (recurse === void 0) { recurse = true; }\n    if (limit === void 0) { limit = Infinity; }\n    if (!Array.isArray(node))\n        node = [node];\n    return find(test, node, recurse, limit);\n}\nexports.filter = filter;\n/**\n * Like `filter`, but only works on an array of nodes.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n */\nfunction find(test, nodes, recurse, limit) {\n    var result = [];\n    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n        var elem = nodes_1[_i];\n        if (test(elem)) {\n            result.push(elem);\n            if (--limit <= 0)\n                break;\n        }\n        if (recurse && tagtypes_1.hasChildren(elem) && elem.children.length > 0) {\n            var children = find(test, elem.children, recurse, limit);\n            result.push.apply(result, children);\n            limit -= children.length;\n            if (limit <= 0)\n                break;\n        }\n    }\n    return result;\n}\nexports.find = find;\n/**\n * Finds the first element inside of an array that matches a test function.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n */\nfunction findOneChild(test, nodes) {\n    return nodes.find(test);\n}\nexports.findOneChild = findOneChild;\n/**\n * Finds one element in a tree that passes a test.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n */\nfunction findOne(test, nodes, recurse) {\n    if (recurse === void 0) { recurse = true; }\n    var elem = null;\n    for (var i = 0; i < nodes.length && !elem; i++) {\n        var checked = nodes[i];\n        if (!tagtypes_1.isTag(checked)) {\n            continue;\n        }\n        else if (test(checked)) {\n            elem = checked;\n        }\n        else if (recurse && checked.children.length > 0) {\n            elem = findOne(test, checked.children);\n        }\n    }\n    return elem;\n}\nexports.findOne = findOne;\n/**\n * Returns whether a tree of nodes contains at least one node passing a test.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n */\nfunction existsOne(test, nodes) {\n    return nodes.some(function (checked) {\n        return tagtypes_1.isTag(checked) &&\n            (test(checked) ||\n                (checked.children.length > 0 &&\n                    existsOne(test, checked.children)));\n    });\n}\nexports.existsOne = existsOne;\n/**\n * Search and array of nodes and its children for nodes passing a test function.\n *\n * Same as `find`, only with less options, leading to reduced complexity.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n */\nfunction findAll(test, nodes) {\n    var _a;\n    var result = [];\n    var stack = nodes.filter(tagtypes_1.isTag);\n    var elem;\n    while ((elem = stack.shift())) {\n        var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(tagtypes_1.isTag);\n        if (children && children.length > 0) {\n            stack.unshift.apply(stack, children);\n        }\n        if (test(elem))\n            result.push(elem);\n    }\n    return result;\n}\nexports.findAll = findAll;\n"]},"metadata":{},"sourceType":"script"}